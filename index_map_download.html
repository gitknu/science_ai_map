<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û—Ñ–ª–∞–π–Ω-–ö–∞—Ä—Ç–∏ (Auto-Offline)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; }
        
        /* UI CONTROLS */
        #controls { 
            padding: 15px; background: #222; color: white; 
            display: flex; gap: 15px; align-items: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 2000;
            flex-wrap: wrap; 
        }
        .group { display: flex; align-items: center; gap: 8px; border-right: 1px solid #555; padding-right: 15px; position: relative; }
        .group:last-child { border-right: none; }
        
        h1 { font-size: 18px; margin: 0; color: #fff; }
        
        button { 
            padding: 8px 16px; cursor: pointer; font-weight: bold; border-radius: 4px; border: none; 
            transition: background 0.2s;
        }
        #btn-download { background: #007bff; color: white; }
        #btn-download:hover { background: #0056b3; }
        #btn-download:disabled { background: #555; cursor: not-allowed; }

        #btn-save-file { background: #6c757d; color: white; display: none; }
        #btn-save-file:hover { background: #5a6268; }

        #btn-loc { background: #17a2b8; color: white; }
        #btn-loc:hover { background: #138496; }
        
        #btn-img-upload { background: #6f42c1; color: white; }
        #btn-img-upload:hover { background: #59359a; }
        
        #btn-img-close { background: #e83e8c; color: white; display: none; }
        #btn-img-close:hover { background: #d63384; }

        #btn-clear { background: #dc3545; color: white; font-size: 12px; padding: 5px 10px;}
        #btn-import { background: #28a745; color: white; font-size: 12px; padding: 5px 10px;}

        /* ROUTE BUTTON */
        #btn-route { background: #fd7e14; color: white; }
        #btn-route:hover { background: #e36a09; }
        .routing-active { outline: 3px solid white; box-shadow: 0 0 10px #fd7e14; }

        /* SEARCH STYLES */
        #search-input { padding: 8px; border-radius: 4px; border: none; width: 220px; }
        #btn-search { background: #ffc107; color: #222; }
        #btn-search:hover { background: #e0a800; }

        /* AUTOCOMPLETE DROPDOWN */
        #search-suggestions {
            position: absolute;
            top: 100%; left: 0; width: 100%;
            background: white;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 3000;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #333;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        .suggestion-item:last-child { border-bottom: none; }
        .suggestion-item:hover { background-color: #f0f0f0; }
        
        /* SWITCH TOGGLE */
        .switch-container { display: flex; align-items: center; gap: 10px; background: #444; padding: 5px 10px; border-radius: 20px; }
        .switch-label { font-size: 14px; font-weight: bold; }
        .toggle-checkbox { height: 0; width: 0; visibility: hidden; position: absolute; }
        .toggle-label {
            cursor: pointer; text-indent: -9999px; width: 40px; height: 20px; background: grey; display: block;
            border-radius: 100px; position: relative;
        }
        .toggle-label:after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 90px; transition: 0.3s;
        }
        .toggle-checkbox:checked + .toggle-label { background: #28a745; }
        .toggle-checkbox:checked + .toggle-label:after { left: calc(100% - 2px); transform: translateX(-100%); }

        /* STATUS BAR */
        #status-bar { background: #f8f9fa; border-bottom: 1px solid #ddd; padding: 5px 15px; font-size: 12px; color: #333; font-family: monospace; }

        /* MAP AREA */
        #map { flex-grow: 1; background: #e5e3df; cursor: crosshair; }

        /* TILE STYLES */
        .cached-tile {
            outline: 2px solid rgba(40, 167, 69, 0.6);
            outline-offset: -2px;
            filter: sepia(0.2) hue-rotate(80deg);
        }
    </style>
</head>
<body>

<!-- CONTROLS -->
<div id="controls">
    <div class="group">
        <h1>–û—Ñ–ª–∞–π–Ω-–ö–∞—Ä—Ç–∞</h1>
    </div>

    <div class="group">
        <div class="switch-container">
            <span class="switch-label">–û–ù–õ–ê–ô–ù</span>
            <input type="checkbox" id="mode-toggle" class="toggle-checkbox" onchange="toggleMode()">
            <label for="mode-toggle" class="toggle-label">Toggle</label>
            <span class="switch-label">–¢–Ü–õ–¨–ö–ò –û–§–õ–ê–ô–ù</span>
        </div>
    </div>

    <div class="group">
        <input type="text" id="search-input" placeholder="–ü–æ—à—É–∫ (–≤—É–ª–∏—Ü—è, –º—ñ—Å—Ü–µ)..." 
               oninput="handleSearchInput(this)" 
               onkeypress="handleSearchEnter(event)"
               autocomplete="off">
        <button id="btn-search" onclick="doSearch()">üîç</button>
        <div id="search-suggestions"></div>
    </div>

    <div class="group">
        <button id="btn-route" onclick="toggleRouteMode()">üîó –ú–∞—Ä—à—Ä—É—Ç</button>
        <input type="file" id="img-input" accept="image/*" style="display: none;" onchange="handleImageUpload(this)">
        <button id="btn-img-upload" onclick="document.getElementById('img-input').click()">üñºÔ∏è –§–æ—Ç–æ</button>
        <button id="btn-img-close" onclick="closeImageMap()">‚úï</button>
    </div>

    <div class="group">
        <button id="btn-loc" onclick="checkLocation()">üìç –Ø —Ç—É—Ç</button>
        <button id="btn-download" onclick="startDownload()">‚¨áÔ∏è –ó–æ–Ω–∞</button>
        <button id="btn-save-file" onclick="exportLastDownload()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —É —Ñ–∞–π–ª</button>
    </div>

    <div class="group" style="margin-left: auto;">
        <input type="file" id="zip-input" accept=".mapzip,.zip" style="display: none;" onchange="importMapArchive(this)">
        <button id="btn-import" onclick="document.getElementById('zip-input').click()">üìÅ –Ü–º–ø–æ—Ä—Ç</button>
        <button id="btn-clear" onclick="clearData()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç–∏</button>
    </div>
</div>

<div id="status-bar">–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–∏...</div>
<div id="map"></div>

<script>
    const CDN_CSS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
    const CDN_JS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
    const CDN_JSZIP = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    
    let map = null, db = null, isOfflineOnly = false, tileLayer = null, searchDebounce = null;
    let noConnectionStart = 0, customMapImage = null, customMapBounds = null, isCustomImageMode = false;
    let isRoutingMode = false, routePoints = [], routeLayer = null, routeMarkers = [];
    let lastDownloadedBounds = null; // Store for manual export

    async function boot() {
        updateStatus("–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É –±—ñ–±–ª—ñ–æ—Ç–µ–∫...");
        let css = localStorage.getItem('lib_css'), js = localStorage.getItem('lib_js'), jszip = localStorage.getItem('lib_jszip');
        if (!css || !js || !jszip) {
            updateStatus("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫...");
            try {
                const [cssRes, jsRes, zipRes] = await Promise.all([fetch(CDN_CSS), fetch(CDN_JS), fetch(CDN_JSZIP)]);
                css = await cssRes.text(); js = await jsRes.text(); jszip = await zipRes.text();
                localStorage.setItem('lib_css', css); localStorage.setItem('lib_js', js); localStorage.setItem('lib_jszip', jszip);
            } catch (e) { updateStatus("–ü–û–ú–ò–õ–ö–ê –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫."); return; }
        }
        const styleTag = document.createElement('style'); styleTag.textContent = css; document.head.appendChild(styleTag);
        const zipTag = document.createElement('script'); zipTag.textContent = jszip; document.body.appendChild(zipTag);
        const scriptTag = document.createElement('script'); scriptTag.textContent = js; document.body.appendChild(scriptTag);
        setTimeout(initApp, 200);
        document.addEventListener('click', e => { if (!e.target.closest('#search-suggestions') && e.target.id !== 'search-input') document.getElementById('search-suggestions').style.display = 'none'; });
        initAutoOfflineProtection();
    }

    function initApp() {
        if (typeof L === 'undefined' || typeof JSZip === 'undefined') return setTimeout(initApp, 100);
        const request = indexedDB.open("StrictOfflineDB", 14);
        request.onupgradeneeded = e => {
            db = e.target.result;
            if (!db.objectStoreNames.contains("tiles")) db.createObjectStore("tiles", { keyPath: "key" });
            if (!db.objectStoreNames.contains("search_cache")) db.createObjectStore("search_cache", { keyPath: "query" });
            if (!db.objectStoreNames.contains("routes_cache")) db.createObjectStore("routes_cache", { keyPath: "key" });
        };
        request.onsuccess = e => { db = e.target.result; updateStatus("–ì–æ—Ç–æ–≤–æ. –û–Ω–ª–∞–π–Ω."); initMap(); };
    }

    function initMap() {
        map = L.map('map').setView([50.4501, 30.5234], 13);
        map.on('click', onMapClick);
        L.TileLayer.Smart = L.TileLayer.extend({
            createTile: function(coords, done) {
                const tile = document.createElement('img'), key = `${coords.z}_${coords.x}_${coords.y}`;
                L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
                L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));
                if (isCustomImageMode && customMapImage && customMapBounds) {
                    const url = getTileFromCustomImage(coords);
                    if (url) { tile.src = url; tile.classList.add('cached-tile'); return tile; }
                }
                const tx = db.transaction("tiles", "readonly");
                tx.objectStore("tiles").get(key).onsuccess = e => {
                    if (e.target.result?.blob) { tile.src = URL.createObjectURL(e.target.result.blob); tile.classList.add('cached-tile'); }
                    else if (isOfflineOnly) tile.src = "data:image/svg+xml;base64," + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256"><rect width="256" height="256" fill="#f0f0f0"/><text x="128" y="128" font-family="Arial" font-size="20" fill="#999" text-anchor="middle">OFFLINE</text></svg>');
                    else tile.src = `https://tile.openstreetmap.org/${coords.z}/${coords.x}/${coords.y}.png`;
                };
                return tile;
            }
        });
        tileLayer = new L.TileLayer.Smart(null, { maxZoom: 18 }).addTo(map);
    }

    function initAutoOfflineProtection() {
        setInterval(async () => {
            if (isOfflineOnly) { noConnectionStart = 0; return; }
            let isConnected = navigator.onLine;
            if (isConnected) {
                try {
                    const ctrl = new AbortController(); setTimeout(() => ctrl.abort(), 2000);
                    await fetch('https://tile.openstreetmap.org/0/0/0.png', { method: 'HEAD', signal: ctrl.signal, cache: 'no-store' });
                } catch (e) { isConnected = false; }
            }
            if (!isConnected) {
                if (noConnectionStart === 0) noConnectionStart = Date.now();
                else if (Date.now() - noConnectionStart > 15000) {
                    document.getElementById('mode-toggle').checked = true; toggleMode(); noConnectionStart = 0;
                    alert("–Ü–Ω—Ç–µ—Ä–Ω–µ—Ç –≤—ñ–¥—Å—É—Ç–Ω—ñ–π >15—Å. –ü–µ—Ä–µ—Ö—ñ–¥ –≤ –æ—Ñ–ª–∞–π–Ω.");
                }
            } else noConnectionStart = 0;
        }, 5000);
    }

    async function startDownload() {
        const btn = document.getElementById('btn-download'), b = map.getBounds();
        document.getElementById('btn-save-file').style.display = 'none';
        let queue = [];
        for (let z = 0; z <= 18; z++) {
             const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
             for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) queue.push({z, x, y});
        }
        const total = queue.length;
        let asArchive = false;
        if (total > 5000) { if (!confirm(`–ó–æ–Ω–∞ ${total} —Ç–∞–π–ª—ñ–≤. –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —è–∫ –∞—Ä—Ö—ñ–≤ (.mapzip)?`)) return; asArchive = true; }
        
        btn.disabled = true;
        const metadataCount = await downloadPlacesMetadata(b);
        const zip = asArchive ? new JSZip() : null;
        let saved = 0; const startTime = Date.now();

        for (let i = 0; i < total; i++) {
            const item = queue[i], elapsed = Date.now() - startTime;
            const timeStr = i > 5 ? `~${Math.ceil(((elapsed/(i+1))*(total-i))/60000)} —Ö–≤` : "...";
            updateStatus(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è ${i+1}/${total} (${timeStr})...`);
            try {
                const r = await fetch(`https://tile.openstreetmap.org/${item.z}/${item.x}/${item.y}.png`);
                if(r.ok) {
                    const blob = await r.blob(), key = `${item.z}_${item.x}_${item.y}`;
                    if (asArchive) zip.file(`${key}.png`, blob);
                    else await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key, blob });
                    saved++;
                }
            } catch(e) {}
            if (i % 25 === 0) await new Promise(r => setTimeout(r, 10));
        }

        if (asArchive) {
            updateStatus("–ó–±—ñ—Ä–∫–∞ –∞—Ä—Ö—ñ–≤—É...");
            const searchData = await getSearchDataInBounds(b);
            zip.file("metadata.json", JSON.stringify(searchData));
            const content = await zip.generateAsync({type:"blob"});
            saveBlob(content, `map_${Date.now()}.mapzip`);
            updateStatus("–ê—Ä—Ö—ñ–≤ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.");
        } else {
            lastDownloadedBounds = b;
            document.getElementById('btn-save-file').style.display = 'inline-block';
            updateStatus(`–ì–æ—Ç–æ–≤–æ! ${saved} —Ç–∞–π–ª—ñ–≤ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.`);
        }
        btn.disabled = false; tileLayer.redraw();
    }

    async function exportLastDownload() {
        if (!lastDownloadedBounds) return;
        updateStatus("–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–∞–π–ª—É...");
        const zip = new JSZip(), b = lastDownloadedBounds;
        const tx = db.transaction("tiles", "readonly"), store = tx.objectStore("tiles");
        let count = 0;
        for (let z = 0; z <= 18; z++) {
            const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
            for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) {
                const key = `${z}_${x}_${y}`;
                const res = await new Promise(r => { store.get(key).onsuccess = e => r(e.target.result); });
                if (res?.blob) { zip.file(`${key}.png`, res.blob); count++; }
            }
        }
        const searchData = await getSearchDataInBounds(b);
        zip.file("metadata.json", JSON.stringify(searchData));
        const content = await zip.generateAsync({type:"blob"});
        saveBlob(content, `export_${count}_tiles.mapzip`);
        updateStatus("–ï–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!");
    }

    async function importMapArchive(input) {
        if (!input.files?.[0]) return;
        updateStatus("–Ü–º–ø–æ—Ä—Ç...");
        try {
            const zip = await JSZip.loadAsync(input.files[0]);
            let count = 0;
            for (const filename of Object.keys(zip.files)) {
                if (filename.endsWith(".png")) {
                    const blob = await zip.files[filename].async("blob");
                    await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key: filename.replace(".png", ""), blob });
                    count++;
                } else if (filename === "metadata.json") {
                    const data = JSON.parse(await zip.files[filename].async("string"));
                    const tx = db.transaction("search_cache", "readwrite");
                    data.forEach(item => tx.objectStore("search_cache").put(item));
                }
                if (count % 100 === 0) updateStatus(`–Ü–º–ø–æ—Ä—Ç: ${count}...`);
            }
            alert(`–Ü–º–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ ${count} —Ç–∞–π–ª—ñ–≤.`); tileLayer.redraw();
        } catch (e) { alert("–ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É"); }
        input.value = "";
    }

    async function getSearchDataInBounds(bounds) {
        return new Promise(res => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                res(e.target.result.filter(i => bounds.contains([i.lat, i.lon])));
            };
        });
    }

    async function downloadPlacesMetadata(bounds) {
        const q = `[out:json][timeout:60];(nwr["name"](${bounds.getSouth()-0.01},${bounds.getWest()-0.01},${bounds.getNorth()+0.01},${bounds.getEast()+0.01}););out center;`;
        try {
            const r = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(q)}`);
            const d = await r.json();
            const tx = db.transaction("search_cache", "readwrite");
            d.elements.forEach(el => {
                const lat = el.lat || el.center?.lat, lon = el.lon || el.center?.lon;
                if (lat && el.tags?.name) tx.objectStore("search_cache").put({ query: el.tags.name.toLowerCase(), lat, lon, display_name: el.tags.name + " (–û—Ñ–ª–∞–π–Ω)" });
            });
            return d.elements.length;
        } catch(e) { return 0; }
    }

    function handleSearchInput(input) {
        const val = input.value.trim().toLowerCase();
        if(val.length < 2) { document.getElementById('search-suggestions').style.display = 'none'; return; }
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                const matches = e.target.result.filter(x => x.query.includes(val)).slice(0, 10);
                const list = document.getElementById('search-suggestions');
                list.innerHTML = '';
                if (!matches.length) { list.style.display = 'none'; return; }
                matches.forEach(item => {
                    const div = document.createElement('div'); div.className = 'suggestion-item'; div.innerHTML = `üìç ${item.display_name}`;
                    div.onclick = () => { document.getElementById('search-input').value = item.display_name.split('(')[0].trim(); moveToLocation(item.lat, item.lon, item.display_name); list.style.display = 'none'; };
                    list.appendChild(div);
                });
                list.style.display = 'block';
            };
        }, 300);
    }

    function doSearch() {
        const q = document.getElementById('search-input').value.trim().toLowerCase();
        db.transaction("search_cache", "readonly").objectStore("search_cache").get(q).onsuccess = e => {
            if (e.target.result) moveToLocation(e.target.result.lat, e.target.result.lon, e.target.result.display_name);
            else if (!isOfflineOnly) searchOnline(q);
        };
    }

    async function searchOnline(query) {
        const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
        const d = await r.json();
        if (d?.[0]) {
            moveToLocation(d[0].lat, d[0].lon, d[0].display_name);
            db.transaction("search_cache", "readwrite").objectStore("search_cache").put({ query, lat: d[0].lat, lon: d[0].lon, display_name: d[0].display_name });
        }
    }

    function toggleRouteMode() {
        isRoutingMode = !isRoutingMode; const btn = document.getElementById('btn-route');
        if (isRoutingMode) { btn.classList.add('routing-active'); routeMarkers.forEach(m => map.removeLayer(m)); routePoints = []; }
        else btn.classList.remove('routing-active');
    }

    function onMapClick(e) {
        if (!isRoutingMode) return;
        routePoints.push(e.latlng); routeMarkers.push(L.marker(e.latlng).addTo(map));
        if (routePoints.length === 2) { calculateRoute(routePoints[0], routePoints[1]); toggleRouteMode(); }
    }

    async function calculateRoute(s, end) {
        const key = `${s.lat.toFixed(3)},${s.lng.toFixed(3)}_${end.lat.toFixed(3)},${end.lng.toFixed(3)}`;
        db.transaction("routes_cache", "readonly").objectStore("routes_cache").get(key).onsuccess = async e => {
            if (e.target.result) drawRoute(e.target.result.geometry, "–û—Ñ–ª–∞–π–Ω");
            else if (!isOfflineOnly) {
                const r = await fetch(`https://router.project-osrm.org/route/v1/driving/${s.lng},${s.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`);
                const d = await r.json();
                if (d.routes?.[0]) {
                    const geo = d.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                    drawRoute(geo, `${(d.routes[0].distance/1000).toFixed(1)} –∫–º`);
                    db.transaction("routes_cache", "readwrite").objectStore("routes_cache").put({ key, geometry: geo });
                }
            }
        };
    }

    function drawRoute(g, l) { if (routeLayer) map.removeLayer(routeLayer); routeLayer = L.polyline(g, { color: 'blue', weight: 5 }).addTo(map); map.fitBounds(routeLayer.getBounds()); updateStatus(`–ú–∞—Ä—à—Ä—É—Ç: ${l}`); }
    function toggleMode() { isOfflineOnly = document.getElementById('mode-toggle').checked; document.getElementById('btn-download').disabled = isOfflineOnly; tileLayer.redraw(); }
    function checkLocation() { navigator.geolocation.getCurrentPosition(p => moveToLocation(p.coords.latitude, p.coords.longitude, "–í–∏ —Ç—É—Ç")); }
    function moveToLocation(lat, lng, t) { map.setView([lat, lng], 15); L.popup().setLatLng([lat, lng]).setContent(t).openOn(map); }
    function handleImageUpload(i) { if (i.files?.[0]) { const r = new FileReader(); r.onload = e => { const img = new Image(); img.onload = () => { customMapImage = img; const c = map.getCenter(), z = map.getZoom(), s = map.getSize(); const sc = Math.min(s.x/img.naturalWidth, s.y/img.naturalHeight)*0.9; const w = img.naturalWidth*sc/2, h = img.naturalHeight*sc/2, cp = map.project(c,z); customMapBounds = L.latLngBounds(map.unproject(L.point(cp.x-w, cp.y-h), z), map.unproject(L.point(cp.x+w, cp.y+h), z)); isCustomImageMode = true; document.getElementById('btn-img-upload').style.display = 'none'; document.getElementById('btn-img-close').style.display = 'inline-block'; tileLayer.redraw(); }; img.src = e.target.result; }; r.readAsDataURL(i.files[0]); } }
    function closeImageMap() { isCustomImageMode = false; document.getElementById('btn-img-upload').style.display = 'inline-block'; document.getElementById('btn-img-close').style.display = 'none'; tileLayer.redraw(); }
    function saveBlob(b, n) { const a = document.createElement("a"); a.href = URL.createObjectURL(b); a.download = n; a.click(); }
    function clearData() { if(confirm("–û—á–∏—Å—Ç–∏—Ç–∏ –±–∞–∑—É?")) { db.transaction("tiles", "readwrite").objectStore("tiles").clear(); db.transaction("search_cache", "readwrite").objectStore("search_cache").clear(); location.reload(); } }
    function updateStatus(m) { document.getElementById('status-bar').innerText = m; }
    function handleSearchEnter(e) { if(e.key === 'Enter') doSearch(); }
    function long2tile(l,z) { return Math.floor((l+180)/360*Math.pow(2,z)); }
    function lat2tile(l,z)  { return Math.floor((1-Math.log(Math.tan(l*Math.PI/180) + 1/Math.cos(l*Math.PI/180))/Math.PI)/2 *Math.pow(2,z)); }
    
    boot();
</script>
</body>
</html>
